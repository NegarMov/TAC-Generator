<h1 align="center">TAC Generator</h1>
<h6 align="center">Fall-2023 Principles of Compiler Design Course Final Project at Amirkabir University of Tech.</h6>


## Introduction
This project is a Three Address Code Generator for a subset of the C language. 
It supports variable and function declaration, function calls, arithmetic operations (priorities are taken into account), and assignments. \
The grammar of the language is defined in [LangGrammar.g4](https://github.com/NegarMov/TAC-Generator/blob/master/LangGrammar.g4) and all the ambiguities along with the dangling else problem are eliminated. 
Other files are generated by ANTLR, and the listeners in [LangGrammarListener.py](https://github.com/NegarMov/TAC-Generator/blob/master/src/LangGrammarListener.py) are implemented to build some synthesized attributes for each node of the parse tree. This way, by traversing the tree in a bottom-up approach, the code attribute of the root node ultimately represents the final TAC to be outputed. 

## Testing the Program
To test this compiler you can simply use the following command in the `src` directory. The result will be outputed to `IRcode.c`.

```bash
python Driver.py <path-to-the-input-file>
```

## Output Example

Here is a sample input to the program and the corresponding output generated by the compiler.

```c
int somefunc(int b, int c) {
    int a = b + c;
    printInt(a + 2);
    return a;
}

int main() {
    int a = somefunc(2, 3);

    if (a < 5) {
        int b = 2, c;
    } else {
        while (a > 5)
            a--;
    }

    return 0;
}
```

```c
#include<stdio.h> 

#define printInt(k) printf("%d\n", k) 
#define printDouble(x) printf("%f\n",x) 
#define printString(t) printf("%s\n", t) 

int readInt() { 
    int x; 
    scanf(" %d", &x); 
    return x; 
} 

double readDouble() { 
    double x; 
    scanf(" %f", &x); 
    return x; 
}

union cell { 
    int i; 
    double d; 
    void* l; 
};

int stack_size = 1000000; 
union cell m[stack_size]; 
int top = 0;
int bottom = stack_size - 1;

int main() {
	
	main:
	m[bottom].i = 2;
	bottom -= 1;
	m[bottom].i = 3;
	bottom -= 1;
	m[top].l = &&L0;
	goto somefunc;
	L0:
	m[top].i = m[top].i;
	top += 1;
	if (m[top - 1].i < 5) goto L1;
	m[top].i = 0;
	goto L2;
	L1:
	m[top].i = 1;
	L2:
	top += 1;
	if (m[top - 4].i == 0) goto L7;
	m[top].i = 2;
	top += 1;
	m[top].i = 0;
	top += 1;
	goto L8;
	L7:
	L5:
	if (m[top - 4].i > 5) goto L3;
	m[top].i = 0;
	goto L4;
	L3:
	m[top].i = 1;
	L4:
	top += 1;
	if (m[top - 1].i == 0) goto L6;
	m[top - 5].i = m[top - 5].i - 1;
	goto L5;
	L6:
	L8:
	m[top].i = 0;
	bottom += 0
	goto main_end;
	
	somefunc:
	m[bottom].i = m[bottom + 2].i + m[bottom + 1].i;
	bottom -= 1;
	m[bottom].i = m[bottom + 1].i;
	bottom -= 1;
	m[bottom].i = m[bottom + 1].i + 2;
	bottom -= 1;
	m[bottom].i = m[bottom + 1].i;
	bottom -= 1;
	printInt(m[bottom + 1].i);
	m[top].i = m[bottom + 2].i;
	bottom += 5
	goto somefunc_end;
	somefunc_end:
	goto *(m[top].l);
	
	main_end:

    return 0
}
```
